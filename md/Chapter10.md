# [Chapter 10](https://livebook.manning.com/book/modern-java-in-action/chapter-10/)

# 람다를 이용한 도메인 전용 언어

## 이 장의 내용
- 도메인 전용 언어(domain-specific languages, DSL)란 무엇이며 어떤 형식으로 구성되는가?
- DSL을 API 에 추가할 때의 장단점
- JVM에서 활용할 수 있는 자바 기반 DSL을 깔끔하게 만드는 대안
- 최신 자바 인터페이스와 클래스에 적용된 DSL에서 배움
- 효과적인 자바 기반 DSL을 구현하는 패턴과 기법
- 이들 패턴을 자바 라이브러리와 도구에서 얼마나 흔히 사용하는가?

- 프로그래밍 언어도 결국 언어
- 메시지를 명확하고, 안정적인 방식으로 전달하는 것
- 개발팀과 도메인 전문가가 공유하고 이해할 수 있는 코드는 생산성과 직결
  - 도메인 전문가는 소프트웨어 개발 프로세스에 참여할 수 있고 비즈니스 관점에서 소프트웨어가 제대로 되었는지 확인할 수 있다. 결과적으로 버그와 오해를 미리 방지할 수 있다.
  - 도메인 전용 언어(DSL)로 애플리케이션의 비즈니스 로직을 표현

- DSL은 작은, 범용이 아니라 특정 도메인을 대상으로 만들어진 특수 프로그래밍 언어
- DSL은 도메인의 많은 특성 용어를 사용


- DLS 예시 (출처: https://unabated.tistory.com/entry/DSLDomain-Specific-Language-이해하기 [랄라라])
  - java
    - ANT, Maven, struts-config.xml, Seasar2 S2DAO, HQL(Hibernate Query Language), JMock
  - Ruby
    - Rails Validations, Rails ActiveRecord, Rake, RSpec, Capistrano, Cucumber
  - 기타
    - SQL, CSS, Regular Expression(정규식), Make, graphviz


- ```java
  while (block != null) {
      read(block, buffer)
          for (every record in buffer) {
              if (record.calorie < 400) {
                  System.out.println (record.name);
              }
          }
      block = buffer.next();
  }
  ```
  - 문제점: 애플리케이션 수준이 아니라 시스템 수준의 개념을 다루고 있음.
- ```java
  menu.stream()
     .filter(d -> d.getCalories() < 400)
     .map(Dish::getName)
     .forEach(System.out::println)
  ```
  - 스트림 API : 보통 자바의 루프의 복잡합 제어와 비교해 유창한 플루언트 스타일(fluent style)


- 기본적으로 DSL을 만들려면 애플리케이션 수준 프로그래머에 어떤 동작이 필요하며 이들을 어떻게 프로그래머에게 제공하는지 고민이 필요하다(동시에 시스템 수준의 개념으로 인해 불필요한 오염이 발생하지 않도록 해야함). 
- 내부적 DSL : 내부적(internal) DSL에서는 위에서 언급한 SQL의 SELECT FROM 구문처럼 애플리케이션 수준의 기본값이 자바 메서드가 사용할 수 있도록 데이터베이스를 대표하는 한 개 이상의 클래스 형식으로 노출된다
- 외부적 DSL : DSL 문법 뿐 아니라 DSL을 평가하는 파서도 구현해야 한다. 하지만 이를 제대로 설계한다면 숙련도가 떨어지는 프로그래머 일지라도 아름답지만 비전문가가 이해하긴 어려운 기존 시스템 수준 코드 환경에서 새 코드를 빠르고 효과적으로 구현할 수 있다.

## 10.1 도메인 전용 언어

- DSL은 특정 비즈니스 도메인의 문제를 해결하려고 만든 언어
- DSL이란 특정 비즈니스 도메인을 **인터페이스**로 만든 API
- DSL은 범용 프로그래밍 언어가 아니다.
- 동작과 용어는 특정 도메인에 국한되므로 다른 문제는 걱정할 필요가 없고 오직 자신의 앞에 놓인 문제를 어떻게 해결할지에만 집중할 수 있다.
  - 관심사의 분리, 구현과 활용의 분리
- 사용자가 특정 도메인의 복잡성을 더 잘 다룰 수 있다
  - 저수준 구현 세부 사항 메서드는 클래스의 비공개로 만들어서 저수준 구현 세부 내용은 숨길 수 있다.
  - 사용자 친화적인 DSL을 만들 수 있다.

- DSL의 역할
  - 의사소통
    - 우리의 코드의 의도가 명확히 전달되어야 하며 프로그래머가 아닌 사람도 이해할 수 있어야 한다. 이런 방식으로 코드가 비즈니스 요구사항에 부합하는지 확인할 수 있다.
  - 가독성
    - 한 번 코드를 구현하지만 여러 번 읽는다, 가독성은 유지 보수의 핵심이다. 즉, 항상 우리의 동료가 쉽게 이해할 수 있도록 코드를 구현해야 한다.

  - DSL은 평문 영어가 아니다.
    - ㅇ
  - 도메인 전문가가 저수준 비즈니스 로직을 구현하도록 만드는 것은 DSL의 역할이 아니다.
    - 

### 10.1.1 DSL의 장점과 단점

- 장점 : 코드의 비즈니스 의도를 명확하게 하고 가독성을 높인다는 점에서 약이 된다
- 단점 : 구현은 코드이므로 올바로 검증하고 유지보수해야하는 책임이 따른다
- 장단점을 모두 고려해서 사용여부를 선택해야 한다

#### 장점

- 간결함 : API는 비즈니스 로직을 간편하게 캡슐화하므로 반복을 피할 수 있고 코드를 간결하게 만들 수 있다.
- 가독성 : 도메인 영역의 용어를 사용하므로 비 도메인 전문가도 코드를 쉽게 이해할 수 있다. 결과적으로 다양한 조직 구성원 간에 코드와 도메인 영역이 공유될 수 있다.
- 유지 보수 : 잘 설계된 이로 구현한 코드는 쉽게 유지 보수하고 바꿀 수 있다. 유지 보수는 비즈니스 관련 코드 즉 가장 빈번히 바뀌는 애플리케이션 부분에 특히 중요하다.
- 높은 수준의 추상화 : 이은 도메인과 같은 추상화 수준에서 동작하므로 도메인의 문제와 직접적으로 관련되지 않은 세부 사항을 숨긴다.
- 집중 : 비즈니스 도메인의 규칙을 표현할 목적으로 설계된 언어이므로 프로그래머가 특정 코드에 집중할 수 있다. 결과적으로 생산성이 좋아진다.
- 관심사 분리(Separation of concerns) : 지정된 언어로 비즈니스 로직을 표현 힘으로 애플리케이션의 인프라 구조와 관련된 문제와 독립적으로 비즈니스

#### 단점

- DSL 설계의 어려움 : 간결하게 제한적인 언어에 도메인 지식을 담는 것이 쉬운 작업은 아니다.
- 개발 비용: 코드에 이을 추가하는 작업은 초기 프로젝트에 많은 비용과 시간이 소모되는 작업이다. 또한 DSL 유지 보수와 변경은 프로젝트에 부담을 주는 요소다.
- 추가 우회 계청 : DSL은 추가적인 계층으로 도메인 모델을 감싸며 이때 계층을 최대한 작게 만들어 성능 문제를 회피한다.
- 새로 배워야 하는 언어 : 요즘에는 한 프로젝트에도 여러 가지 언어를 사용하는 추세다. 하지만 DSL을 프로젝트에 추가하면서 팀이 배워야 하는 언어가 한 개 더 늘어난다는 부담이 있다. 여러 비즈니스 도메인을 다루는 개별 이을 사용하는 상황이라면 이들을 유기적으로 동작하도록 합치는 일은 쉬운 일이 아니다. 개별 DSL이 독립적으로 진화할 수 있기 때문이다.
- 호스팅 언어 한계 : 일부 자바 같은 범용 프로그래밍 언어는 장황하고 엄격한 문법을 가졌다. 이런 언어로는 사용자 친화적 DSL을 만들기가 힘들다. 사실 장황한 프로그래밍 언어를 기반으로 만든 이은 성가신 문법의 제약을 받고 읽기가 어려워진다. 자바 8의 람다 표현식은 이 문제를 해결할 강력한 새 도구다.

### 10.1.2 JVM에서 이용할 수 있는 다른 DSL 해결책

#### 내부 DSL

- 내부 DSL이란 호스팅언어(=자바)로 구현한 DSL을 의미
- 역사적으로 자바는 다소 귀찮고, 유연성이 떨어지는 문법 때문에 읽기 쉽고, 간단하고, 표현력 있는 DSL을 만 드는 데 한계가 있었다. 람다 표현식이 등장하면서 이 문제가 어느 정도 해결될 수 있다.
- 신호 대비 잡음 비율
  -  나머지 코드는 특별한 기능을 더하지 않고 문법상 필요한 잡음

- 장점
  - 기존 자바 언어를 이용하면 외부DSL에 비해 새로운 패턴과 기술을 배워 이을 구현하는 노력이 현저하게 줄어든다.
  - 순수 자바로 DSL을 구현하면 나머지 코드와 함께 DSL을 컴파일할 수 있다. 따라서 다른 언어의 컴파일러를 이용하거나 외부 DSL을 만드는 도구를 사용할 필요가 없으므로 추가로 비용이 들지 않는다.
  - 여러분의 개발 팀이 새로운 언어를 배우거나 또는 익숙하지 않고 복잡한 외부 도구를 배울 필요가 없다.
  - DSL 사용자는 기존의 자바 IDE를 이용해 자동 완성, 자동 리 팩터링 같은 기능을 그대로 즐길 수 있다. 최신 IDE는 다른 유명한 JVM 언어도 지원하지만 자바만큼의 기능을 지원하진 못한다.
  - 한 개의 언어로 한 개의 도메인 또는 여러 도메인을 대응하지 못해 추가로 DSL을 개발해야 하는 상황에서 자바를 이용한다면 추가 DSL을 쉽게 합칠 수 있다.

#### 다중 DSL

- 같은 자바 바이트코드를 사용하는 JVM 기반 프로그래밍 언어를 이용함으로 DSL 합침 문제를 해결
- 코틀린(Kotlin)과 스칼라(Scala), 자이썬(Jython), 제이루비(JRuby) 등
- [자바를 넘어선 JVM 기반 프로그래밍 언어들](https://www.itworld.co.kr/news/109008)
- 자바보다 젊으며 제약을 줄이고, 간편한 문법을 지향하도록 설계되었다. DSL은 기반 프로그래밍 언어의 영향을 받으므로 간결한 DSL을 만 드는 데 새로운 언어의 특성들이 아주 중요하다.
- 작은 스칼라 내장 DSL 구현 사용자는 다음 처럼 "Hello World"를 세 번 출력하는 함수를 실행할 수 있다.
- ```java
  3 times {
      println("Hello World")
  }
  ```
- 장점
  - 문법적 잡음이 전혀 없으며 개발자가 아닌 사람도 코드를 쉽게 이해할 수 있다
- 단점
  - 새로운 프로그래밍 언어를 배우거나 또는 팀의 누군가가 이미 해당 기술을 가지고 있어야 한다. 멋진 DSL을 만들려면 이미 기존 언어의 고급 기능을 사용할 수 있는 충분한 지식이 필요하기 때문이다.
  - 두 개 이상의 언어가 혼재하므로 여러 컴파일러로 소스를 빌드하도록 빌드 과정을 개선해야 한다.
  - 마지막으로 JVM에서 실행되는 거의 모든 언어가 자바와 백 퍼센트 호환을 주장하고 있지만 자바와 호환성이 완벽하지 않을 때가 많다. 이런 호환성 때문에 성능이 손실될 때도 있다. 예를 들어 스칼라와 자바 컬렉션은 서로 호환되지 않으므로 상호 컬렉션을 전달하려면 기존 컬렉션을 대상 언어의 API에 맞게 변환해야 한다.

#### 외부 DSL

- 자신만의 문법과 구문으로 새 언어를 설계
- 새 언어를 파싱하고, 파서의 결과를 분석하고, 외부 DSL을 실행할 코드를 만들어야 한다
- 장점
  - 무한한 유연성
  - 필요한 특성을 완벽하게 제공하는 언어를 설계할 수 있다
  - 제대로 언어를 설계하면 우리의 비즈니스 문제를 묘사하고 해결하는 가독성 좋은 언어를 얻을 수 있다
  - 자바로 개발된 인프라구조 코드와 외부 DSL로 구현한 비즈니스 코드를 명확하게 분리
    - DSL과 호스트 언어 사이에 인공 계층이 생기므로 이는 양날의 검
- 단점
  - 아주 큰 작업
  - 일반적인 작업도 아니며 쉽게 기술을 얻을 수도 없다
  - 논리 정연한 프로그래밍 언어를 새로 개발한다는 것은 간단한 작업이 아니다

## 10.2 최신 자바 API의 작은 DSL



## 10.3



## 10.4



## 10.5


