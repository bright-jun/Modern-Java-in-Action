# [Chapter 13](https://livebook.manning.com/book/modern-java-in-action/chapter-13/)

# 디폴트 메서드

## 이 장의 내용

- 디폴트 메서드란 무엇인가?
- 진화하는 API 가 호환성을 유지하는 방법
- 디폴트 메서드의 활용 패턴
- 해결 규칙

## 도입

- 인터페이스
    - 구현 시, 추상메소드들을 모두 구현
- 인터페이스를 바꾼다면?
    - 이전에 해당 인터페이스를 구현했던 모든 클래스의 구현도 고쳐야 함
        - 컬렉션 프레임워크인 Guava, Apache Common 등 을 포함해서 기존의 List 인터페이스를 구현했던 모든 프로그래머가 sort 메서드를 구현하도록
          List 인터페이스를 상속한 모든 클래스를 고쳐야 한다고 발표한다면...?!
        - 라이브러리 설계자 입장에서 인터페이스에 새로운 메서드를 추가하는 등 인터페이스를 바꾸고 싶을 때는 문제가 발생
    - 자바 8 API에도 List 인터페이스에 sort 같은 메서드를 추가했었음
- 해결방안
    1. 정적 메서드(static method)
        1. `static` and `private static` method in interface were introduced in Java 9
    2. 디폴트 메서드(default method)
        1. 주로 라이브러리 설계자들이 사용
        2. 자바 API의 호환성을 유지하면서 라이브러리를 바꿀 수 있다
        3. ![Figure 13.1. Adding a method to an interface](https://drek4537l1klr.cloudfront.net/urma2/Figures/13fig01_alt.jpg)
        4. 다중 상속 동작이라는 유연성을 제공하면서 프로그램 구성에도 도움을 준다(이제 클래스는 여러 디폴트 메서드를 상속받을 수 있게 되었다)

## 정적 메서드와 인터페이스

- 보통 자바에서는 인터페이스 그리고 인터페이스의 인스턴스를 활용할 수 있는 다양한 정적 메서드를 정의하는 유틸리티 클래스를 활용한다. 예를 들어 `Collections`는
  `Collection` 객체를 활용할 수 있는 유틸리티 클래스다. 자바 8에서는 인터페이스에 직접 정적 메서드를 선언할 수 있으므로 유틸리티 클래스를 없애고 직접 인터페이스
  내부에 정적 메서드를 구현할 수 있다.
- 그럼에도 불구하고 __과거 버전과의 호환성을 유지할 수 있도록__ 자바 API에는 유틸리티 클래스가 남아있다.

## 13.1 변화하는 API

- API가 바뀌면서 발생한 문제

### 13.1.1 API 버전 1

```java
public interface Resizable {

    int getWidth();

    int getHeight();

    void setWidth(int width);

    void setHeight(int height);

    void setAbsoluteSize(int width, int height);
}
```

### 13.1.2 API 버전 2

```java
public interface Resizable {

    int getWidth();

    int getHeight();

    void setWidth(int width);

    void setHeight(int height);

    void setAbsoluteSize(int width, int height);

    void setRelativeSize(int wFactor, int hFactor); // version 2 에 추가된 메서드
}
```

- 그림 13-2 Resizable에 메서드를 추가하면서 API가 바뀌었다. 따라서 인터페이스를 바꾼 다음에 애플리케이션을 재컴파일하면 에러가 발생한다.
- ![Figure 13.2. Evolving an API by adding a method to Resizable. Recompiling the application produces errors because it depends on the Resizable interface.](https://drek4537l1klr.cloudfront.net/urma2/Figures/13fig02_alt.jpg)

#### 문제점

1. `Resizable`을 구현하는 모든 클래스는 `setRelativeSize` 메서드를 구현해야 한다.
    1. 라이브러리 사용자가 직접 구현한 `Ellipse`는 `setRelativeSize` 메서드를 구현하지 않는다
    2. 바이너리 호환성은 유지가 된다
        1. 새로 추가된 메서드를 호출하지만 않으면 새로운 메서드 구현이 없이도 기존 클래스 파일 구현이 잘 동작한다는 의미
        2. 즉 새로 추가된 메서드를 호출하면 런타임 에러가 발생
        3. [TODO] 해당 런타임에러는 어떻게 발생시킬 수 있는지? 컴파일 에러가 발생함
2. `Ellipse`를 포함하는 전체 애플리케이션을 재빌드할 때 다음과 같은 컴파일 에러가 발생
    1. ```
   java: exercise.chapter13.Ellipse is not abstract and does not override abstract method
   setRelativeSize(int,int) in exercise.chapter13.Resizable
      ```
    2. 공개된 API를 고치면 기존 버전과의 호환성 문제가 발생
        1. 공식 자바 컬렉션 API 같은 기존의 API는 고치기 어렵다

#### 대안

1. 자신만의 API를 별도로 만든 다음에 예전 버전과 새로운 버전을 직접 관리
    1. 라이브러리를 관리하기가 복잡하다.
    2. 사용자는 같은 코드에 예전 버전과 새로운 버전 두 가지 라이브러리를 모두 사용해야 하는 상황이 생긴다. 결국 프로젝트에서 로딩해야 할 클래스 파일이 많아지면서 메모리
       사용과 로딩 시간 문제가 발생
2. 디폴트 메서드
    1. 새롭게 바뀐 인터페이스에서 자동으로 기본 구현을 제공하므로 기존 코드를 고치지 않아도 된다

### 바이너리 호환성, 소스 호환성, 동작 호환성

- 자바 프로그램을 바꾸는 것과 관련된 호환성 문제(더 자세한 사항은 http://goo.gl/JNn4vm 참고)
- 바이너리 호환성
    - 인터페이스에 메서드를 추가했을 때는 바이너리 호환성을 유지하지만 인터페이스를 구현하는 클래스를 재컴파일하면 에러가 발생한다.
    - 뭔가를 바꾼 이후에도 에러 없이 기존 바이너리가 실행될 수 있는 상황을 바이너리 호환성이라고 한다(바이너리 실행에는 인증 verification, 준비
      preparation, 해석 resolution 등의 과정이 포함된다). 예를 들어 인터페이스에 메서드를 추가했을 때 추가된 메서드를 호출하지 않는 한 문제가 일어나지
      않는데 이를 바이너리 호환성이라고 한다.
- 소스 호환성
    - 소스 호환성이란 코드를 고쳐도 기존 프로그램을 성공적으로 재컴파일할 수 있음을 의미한다. 예를 들어 인터페이스에 메서드를 추가하면 소스 호환성이 아니다. 추가한 메서드를
      구현하도록 클래스를 고쳐야 하기 때문이다.
- 동작 호환성
    - 동작 호환성이란 코드를 바꾼 다음에도 같은 입력값이 주어지면 프로그램이 같은 동작을 실행한다는 의미다. 예를 들어 인터페이스에 메서드를 추가하더라도 프로그램에서 추가된
      메서드를 호출할 일은 없으므로(혹은 우연히 구현 클래스가 이를 오버라이드 했을 수도 있다) 동작 호환성은 유지된다.

## 13.2 디폴트 메서드란 무엇인가?

- 인터페이스는 자신을 구현하는 클래스에서 메서드를 구현하지 않을 수 있는 새로운 메서드 시그니처(`default`)를 제공
- 인터페이스를 구현하는 클래스에서 구현하지 않은 메서드는 인터페이스 자체에서 기본(`default`)으로 제공
- 인터페이스에 디폴트 메서드를 추가하면 소스 호환성이 유지
    - 라이브러리 사용자는 인터페이스를 구현하는 클래스를 고칠 필요가없다

- `Predicate`, `Function`, `Comparator` 등 많은 함수형 인터페이스도 `Predicate.and` 또는 `Function.andThen` 같은 다양한
  디폴트 메서드를 포함한다
    - 함수형 인터페이스는 오직 하나의 추상 메서드를 포함한다.
    - 디폴트 메서드는 추상 메서드에 해당하지 않기에 함수형 인터페이스도 디폴트 메서드 구현이 가능

### 추상 클래스 vs 자바 8의 인터페이스

- 공통점
    - 둘 다 추상 메서드와 바디를 포함하는 메서드를 정의 할수 있다.
- 차이점
    1. 클래스는 하나의 추상 클래스만 상속받을 수 있지만 인터페이스를 다중 상속을 지원.
        1. 추상클래스와는 다르게 구현을 하지 않은 상태기 때문에 **모호함**이 없음
    2. 추상 클래스는 인스턴스 변수(필드)로 공통 상태를 가질 수 있다. 하지만 인터페이스는 인스턴스 변수를 가질 수 없다.

## 13.3 디폴트 메서드 활용 패턴

### 13.3.1 선택형 메서드

- 인터페이스를 구현하는 클래스에서 메서드의 내용이 비어있는 상황
- `Iterator`
    - `remove`에 빈 구현을 제공
    - 기본 구현이 제공되므로 `Iterator` 인터페이스를 구현하는 클래스는 빈 `remove` 메서드를 구현할 필요가 없어짐
        - 불필요한 코드를 줄일 수 있다.

```java
interface Iterator<T> {

    boolean hasNext();

    T next();

    default void remove() {
        throw new UnsupportedOperationException();
    }
}
```

### 13.3.2 동작다중상속

- ![그림 13-3 단일 상속과 다중 상속](https://drek4537l1klr.cloudfront.net/urma2/Figures/13fig03_alt.jpg)

```java
public class ArrayList<E> extends AbstractList<E>
    implements List<E>, RandomAccess, Cloneable, Serializable {

}
```

- 자바 8에서는 인터페이스가 구현을 포함
    - 클래스는 여러 인터페이스에서 동작(구현 코드)을 상속받을 수 있다
    - 중복되지 않는 최소한의 인터페이스를 유지한다면 우리 코드에서 동작을 쉽게 재사용하고 조합할 수 있다.

- 기능이 중복되지 않는 최소의 인터페이스
    - 구현해야 할 다른 메서드에 따라 뼈대 알고리즘이 결정되는 템플릿 디자인 패턴과 비슷해 보인다
- 인터페이스 조합
    - ![그림 13-4 다중 동작조합](https://drek4537l1klr.cloudfront.net/urma2/Figures/13fig04_alt.jpg)

- 디폴트 메서드 덕분에 `Moveable` 인터페이스를 직접 고칠 수 있고 따라서 `Moveable`을 구현하는 모든 클래스도 자동으로 변경한 코드를 상속받는다(물론 구현
  클래스에서 메서드를 정의하지 않은 상황에 한해서다

#### 옳지 못한 상속

- 상속으로 코드 재사용 문제를 모두 해결할 수 있는 것은 아니다. 예를 들어 한 개의 메서드를 재사용하려고 100개의 메서드와 필드가 정의되어 있는 클래스를 상속받는 것은 좋은
  생각이 아니다. 이럴 때는 델리게이션delegation, 즉 멤버 변수를 이용해서 클래스에서 필요한 메서드를 직접 호출하는 메서드를 작성하는 것이 좋다. 종종 `final`로
  선언된 클래스를 볼 수 있다. 다른 클래스가 이 클래스를 상속받지 못하게 함으로써 원래 동작이 바뀌지 않길 원하기 때문이다. 예를 들어 `String` 클래스도 `final`로
  선언되어 있다. 이렇게 해서 다른 누군가가 `String`의 핵심 기능을 바꾸지 못하도록 제한할 수 있다. 우리의 디폴트 메서드에도 이 규칙을 적용할 수 있다. 필요한 기능만
  포함하도록 인터페이스를 최소한으로 유지한다면 필요한 기능만 선택할 수 있으므로 쉽게 기능을 조립할 수 있다.

## 13.4 해석 규칙

- 디폴트 메서드의 다중 상속으로 인한 모호함이 발생함
- 다이아몬드 문제

### 13.4.1 알아야 할 세 가지 해결 규칙

1. 클래스가 항상 이긴다. 클래스나 슈퍼클래스에서 정의한 메서드가 디폴트 메서드보다 우선권을 갖는다.
2. 1번 규칙 이외의 상황에서는 서브 인터페이스가 이긴다. 상속관계를 갖는 인터페이스에서 같은 시그니처를 갖는 메서드를 정의할 때는 서브 인터페이스가 이긴다. 즉, B가 A를
   상속받는다면 B가 A를 이긴다.
3. 여전히 디폴트 메서드의 우선순위가 결정되지 않았다면 여러 인터페이스를 상속받는 클래스가 명시적으로 디폴트 메서드를 오버라이드하고 호출해야 한다.

### 13.4.2 디폴트 메서드를 제공하는 서브인터페이스가 이긴다

- ![그림 13-5 디폴트 메서드를 제공하는 가장 하위의 서브인터페이스가 이긴다.](https://drek4537l1klr.cloudfront.net/urma2/Figures/13fig05_alt.jpg)
- "Hello from B"
- ![그림 13-6 하나의 클래스를 상속받아 두 개의 인터페이스를 구현](https://drek4537l1klr.cloudfront.net/urma2/Figures/13fig06_alt.jpg)

### 13.4.3 충돌 그리고 명시적인 문제 해결

- ![그림 13-7 두 개의 인터페이스 구현](https://drek4537l1klr.cloudfront.net/urma2/Figures/13fig07.jpg)

### 13.4.4 다이아몬드 문제

- ![그림 13-8 다이아몬드 문제](https://drek4537l1klr.cloudfront.net/urma2/Figures/13fig08_alt.jpg)

#### C++ 다이아몬드 문제

- C++의 다이아몬드 문제는 이보다 더 복잡하다. 우선 C++는 클래스의 다중 상속을 지원한다. 클래스 D가 클래스 B와〔를 상속받고 B와〔는 클래스 A를 상속받는다고 가정하자.
  그러면 클래스 D는 B 객체와〔 객체의 복사본에 접근할 수 있다. 결과적으로 A의 메서드를 사용할 때 B의 메서드인지〔의 메서드인지 명시적으로 해결해야 한다. 또한 클래스는
  상태를 가질 수 있으므로 B의 멤버 변수를 고쳐도 C 객체의 복사본에 반영되지 않는다

## 13.5 마치며

- 자바 8의 인터페이스는 구현 코드를 포함하는 디폴트 메서드, 정적 메서드를 정의할 수 있다.
- 디폴트 메서드의 정의는 default 키워드로 시작하며 일반 클래스 메서드처럼 바디를 갖는다.
- 공개된 인터페이스에 추상 메서드를 추가하면 소스 호환성이 깨진다.
- 디폴트 메서드 덕분에 라이브러리 설계자가 API를 바꿔도 기존 버전과 호환성을 유지할 수 있다.
- 선택형 메서드와 동작 다중 상속에도 디폴트 메서드를 사용할 수 있다.
- 클래스가 같은 시그니처를 갖는 여러 디폴트 메서드를 상속하면서 생기는 충돌 문제를 해결하는 규칙이 있다.
- 클래스나 슈퍼클래스에 정의된 메서드가 다른 디폴트 메서드 정의보다 우선한다. 이 외의 상황에서는 서브 인터페이스에서 제공하는 디폴트 메서드가 선택된다.
- 두 메서드의 시그니처가 같고, 상속관계로도 충돌 문제를 해결할 수 없을 때는 디폴트 메서드를 사용하는 클래스에서 메서드를 오버라이드 해서 어떤 디폴트 메서드를 호출할지
  명시적으로 결정해야 한다.