# [Chapter 05](https://livebook.manning.com/book/modern-java-in-action/chapter-5/)

## 스트림 활용

### 5.1 필터링

#### 5.1.1 프레디케이트로 필터링

- filter
  - filter 메서드는 프레디케이트(불리언을 반환하는 함수)를 인수로 받아서 프레디케이트와 일치하는 모든 요소를 포함하는 스트림을 반환한다.
- ![그림 5-1 프레디케이트로 스트림 필터링하기](https://drek4537l1klr.cloudfront.net/urma2/Figures/05fig01_alt.jpg)

#### 5.1.2 고유요소 필터링

- distinct
  - 고유 요소로 이루어진 스트림을 반환
  - 고유 여부는 스트림에서 만든 객체의 hashCode, equals로 결정된다
- ![그림 5-2 스트림에서 고유 요소만 필터링](https://drek4537l1klr.cloudfront.net/urma2/Figures/05fig02_alt.jpg)

### 5.2 스트림 슬라이싱

#### 5.2.1 프레디케이트를 이용한 슬라이싱

- 자바 9은 스트림의 요소를 효과적으로 선택할 수 있도록 `takeWhile`, `dropWhile` 두 가지 새로운 메서드를 지원한다.

##### TAKEWHILE

- 리스트가 이미 정렬되어 있다는 사실을 이용해 320칼로리보다 크거나 같은 요리가 나왔을 때 반복 작업을 중단 할 수 있다.
- `takeWhile`을 이용하면 무한스트림을 포함한 모든 스트림에 프레디 케이트를 적용해 스트림을 슬라이스할 수 있다.

##### DROPWHILE

- `dropWhile`은 `takeWhile`과 정반대의 작업을 수행
- `dropWhile`은 프레디케이트가 처음으로 거짓이 되는 지점까지 발견된 요소를 버린다. 프레디케이트가 거짓이 되면 그 지점에서 작업을 중단하고 남은 모든 요소를 반환한다.
- 무한한 남은 요소를 가진 무한 스트림에서도 동작한다

#### 5.2.2 스트림 축소

- 스트림은 주어진 값 이하의 크기를 갖는 새로운 스트림을 반환하는 `limit(n)` 메서드를 지원한다.
- 스트림이 정렬되어 있으면 최대 요소 `n`개를 반환할 수 있다.
  - 정렬되지 않은 스트림 (예를 들면 소스가 `Set`)에도 `limit`를 사용할 수 있다.
  - 소스가 정렬되어 있지 않았다면 `limit`의 결과도 정렬되지 않은 상태로 반환된다.
- ![그림 5-3 스트림 연결](https://drek4537l1klr.cloudfront.net/urma2/Figures/05fig03_alt.jpg)

#### 5.2.3 요소 건너뛰기

- 스트림은 처음 `n`개 요소를 제외한 스트림을 반환하는 `skip(n)` 메서드를 지원한다.
- `n`개 이하의 요소를 포함하는 스트림에 `skip(n)`을 호출하면 빈 스트림이 반환된다. `limit(n)`과 `skip(n)` 은 상호 보완적인 연산을 수행한다.
- ![그림 5-4 스트림의 요소 건너뛰기](https://drek4537l1klr.cloudfront.net/urma2/Figures/05fig04_alt.jpg)

### 5.3 매핑

#### 5.3.1 스트림의 각 요소에 함수 적용하기

- 스트림은 함수를 인수로 받는 `map` 메서드를 지원한다.
- 인수로 제공된 함수는 각 요소에 적용되 며 함수를 적용한 결과가 새로운 요소로 매핑된다
- 이 과정은 기존의 값을 '고친다(modify)'라는 개념보다는 '새로운 버전을 만든다'라는 개념에 가까우므로 '변환(transforming)'에 가까운 '매핑(mapping)' 이라는 단어를 사용한다.

#### 5.3.2 스트림 평면화

- `map`을 응용해서 리 스트에서 고유 문자로 이루어진 리스트를 반환해보자
- ![그림 5-5 map을 이용해서 단어 리스트에서 고유 문자를 찾는 데 실패한 사례](https://drek4537l1klr.cloudfront.net/urma2/Figures/05fig05_alt.jpg)

##### map과 Arrays.stream 활용

##### flatMap 사용

- `flatMap`은 각 배열을 스트림이 아니라 스트림의 콘텐츠로 매핑한다.
- 즉, `map(Arrays::stream)` 과 달리 `flatMap`은 하나의 평면화된 스트림을 반환한다.
- 스트림의 각 값을 다른 스트림으로 만든 다음에 모든 스트림을 하나의 스트림으로 연결하는 기능을 수행한다.

- ![그림 5-6 flatMap을 이용해서 단어 리스트에서 고유 문자 찾기](https://drek4537l1klr.cloudfront.net/urma2/Figures/05fig06_alt.jpg)

- 10장에서는 `null`을 확인하는 새로운 라이브러리 클래스인 `Optional`이라는 고급 자바 8 패턴 을 설명하면서 `flatMap`을 다시 설명한다.

### 5.4 검색과 매칭

#### 5.4.1 프레디케이트가 적어도 한 요소와 일치하는지 확인

#### 5.4.2 프레디케이트가 모든 요소와 일치하는지 검사

##### NONEMATCH

#### 쇼트서킹 평가

> 때로는 전체 스트림을 처리하지 않았더라도 결과를 반환할 수 있다.
> 예를 들어 여러 `and` 연산으로 연결된 커다란 불리언 표현식을 평가한다고 가정하자.
> 표현식에서 하나라도 거짓이라는 결 과가 나오면 나머지 표현식의 결과와 상관없이 전체 결과도 거짓이 된다.
> 이러한 상황을 쇼트 서킷이라고 부른다. `allMatch`, `noneMatch`, `findFirst`, `findAny` 등의 연산은 모든 스트림의 요소를 처리하지 않고도 결과를 반환할수 있다.
> 원하는 요소를찾았으면 즉시 결과를 반환할수 있다. 마찬가지로 스트림의 모든 요소를 처리할 필요 없이 주어진 크기의 스트림을 생성하는 `limit`도 쇼트서킷 연산이다.
> 특히 무한한 요소를 가진 스트림을 유한한 크기로 줄일 수 있는 유용한 연산이다. 5.7절에서 무한 스트림의 예제를 살펴본다.

#### 5.4.3 요소 검색

- `findAny`메서드는 현재 스트림에서 임의의 요소를 반환한다.
- `findAny`메서드를 다른 스트림 연산과 연결해서 사용할 수 있다.

#### Optional 이란?

- `Optional<T>` 클래스(java.util.Optional)는 값의 존재나 부재 여부를 표현하는 컨테이너 클래스다.
- 이전 예제에서 `findAny`는 아무 요소도 반환하지 않을 수 있다. `null`은 쉽게 에러를 일으킬 수 있으므로 자바 8 라이브러리 설계자는 `Optional<T>`를 만들었다.
- `isPresent()`는 `Optional`이 값을 포함하면 참(`true`)을 반환하고, 값을 포함하지 않으면 거짓 (`false`) 을 반환한다.
- `ifPresent(Consumer<T> block)`은 값이 있으면 주어진 블록을 실행한다. Consumer 함수 형 인터페이스는 3장에서 설명했다. Consumer 함수형 인터페이스에는 T 형식의 인수를 받으며 void를 반환하는 람다를 전달할 수 있다.
- `T get()`은 값이 존재하면 값을 반환하고, 값이 없으면 `NoSuchElementException`을 일으킨다.
- `T orElse(T other)`는 값이 있으면 값을 반환하고，값이 없으면 기본값을 반환한다.

#### 5.4.4 첫 번째 요소 찾기

- 논리적인 아이템 순서가 정해져 있을 수 있다. 

> `findFirst`와 `findAny`는 언제 사용하나? 
> 
> 그런데 왜 `findFirst`와 `findAny` 메서드가 모두 필요할까?
> 바로 병렬성 때문이다. 병렬 실행에서는 첫 번째 요소를 찾기 어렵다.
> 따라서 요소의 반환 순서가 상관없다면 병렬 스트림에서는 제약이 적은 `findAny`를 사용한다.

### 5.5 리듀싱

- '메뉴의 모든 칼로리의 합계를 구하시오', '메뉴에서 칼로리가 가장 높은 요리는?' 같이 스트림 요소를 조합해서 더 복잡한 질의를 표현하는 방법을 설명한다.
- 이러한 질의를 수행하려면 `Integer` 같은 결과가 나올 때까지 스트림의 모든 요소를 반복적으로 처리해야 한다.
- 이런 질의를 리듀싱 연산(모든 스트림 요소를 처리해서 값으로 도출하는)이라고 한다.
- 함수형 프로그래밍 언어 용어로는 이 과정이 마치 종이(우리의 스트림)를 작은 조각이 될 때까지 반복해서 접는 것과 비슷하다는 의미로 폴드(fold)라고 부른다.

#### 5.5.1 요소의 합

![그림 5-7 reduce를 이용해서 스트림의 모든 숫자 더하기](https://drek4537l1klr.cloudfront.net/urma2/Figures/05fig07_alt.jpg)

- 왜 Optional〈Integer〉를 반환하는 걸까?
- 스트림에 아무 요소도 없는 상황을 생각해보자. 이런 상황이라면 초깃값이 없으므로 reduce는 합계를 반환할 수 없다. 따라서 합계가 없음을 가리킬 수 있도록 Optional 객체로 감싼 결과를 반환한다.

[java-functional-interface](https://johngrib.github.io/wiki/java-functional-interface/)

#### 5.5.2 최댓값과 최솟값

- reduce는 두 인수를 받는다.
  - 초깃값
  - 스트림의 두 요소를 합쳐서 하나의 값으로 만드는 데 사용할 람다

![그림 5-8 리듀싱 연산: 최댓값 계산](https://drek4537l1klr.cloudfront.net/urma2/Figures/05fig08_alt.jpg)

> `reduce` 메서드의 장점과 병렬화
> 
> 기존의 단계적 반복으로 합계를 구하는 것과 `reduce`를 이용해서 합계를 구하는 것은 어떤 차이가 있을까?
> `reduce`를 이용하면 내부 반복이 추상화되면서 내부 구현에서 병렬로 `reduce`를 실행할 수 있게 된다.
> 반복적인 합계에서는 sum 변수를 공유해야 하므로 쉽게 병렬화하기 어렵다.
> 강제적으로 동기화시키더라도 결국 병렬화로 얻어야 할 이득이 스레드 간의 소모적인 경쟁 때문에 상쇄되어 버린다는 사실을 알게 될 것이다.
> 사실 이 작업을 병렬화하려면 입력을 분할하고, 분할된 입력을 더한 다음에, 더한 값을 합쳐야 한다. 지금까지 살펴본 코드와는 조금 다른 코드 가 나타난다.
> 7장에서는 포크/조인 프레임워크(fork/join framework)를 이용하는 방법을 살펴본다.
> 지금 중요한 사실은 가변 누적자 패턴(mutable accumulator pattern)은 병렬화와 거리가 너무 먼 기법이라는 점이다.
> 우리에겐 reduce라는 새로운 패턴이 필요하다.
> 7장에서는 스트림의 모든 요소를 더 하는 코드를 병렬로 만드는 방법도 설명한다.
> 바로 `stream()`을 `parallelStream()`으로 바꾸면 된다.
> int sum = numbers.parallelStream().reduce(0, Integer::sum);
> 나중에 자세히 설명하겠지만 위 코드를 병렬로 실행하려면 대가를 지불해야 한다.
> 즉，reduce에 넘겨준 람다의 상태(인스턴스 변수 같은)가 바뀌지 말아야 하며, 연산이 어떤 순서로 실행되더라도 결과가 바뀌지 않는 구조여야 한다.

> 스트림 연산 : 상태 없음과 상태 있음
> 
> 컬렉션으로 스트림을 만드는 stream 메서드를 parallelStream로 바꾸는 것만으로도 별다른 노력 없이 병렬성을 얻을 수 있다.
1. map, filter 등은 입력 스트림에서 각 요소를 받아 0 또는 결과를 출력 스트림으로 보낸다. 
   - 따라서 사용자가 제공한 람다나 메서드 참조가 내부적인 가변 상태를 갖지 않는다는 가정하에）이들은 보통 상태가 없는，즉 내부 상태를 갖지 않는 연산(stateless operation)이다.
2. 하지만 reduce, sum, max 같은 연산은 결과를 누적할 내부 상태가 필요하다.
   - 예제의 내부 상태는 작은 값이다. 우리 예제에서는 int 또는 double을 내부 상태로 사용했다.
   - 스트림에서 처리하는 요소 수와 관계없이 내부 상태의 크기는 한정(bounded)되어 있다
3. 반면 sorted나 distinct 같은 연산은 filter나 map처럼 스트림을 입력으로 받아 다른 스트림을 출력하는 것처럼 보일 수 있다. 
   - 하지만 sorted나 distinct는 filter나 map과는 다르다. 스트림의 요소를 정렬하거나 중복을 제거하려면 과거의 이력을 알고 있어야 한다.
   - 예를 들어 어떤요소를 출력 스트림으로 추가하려면 모든 요소가 버퍼에 추가되어 있어야 한다. 연산을 수행하는 데 필요한 저장소 크기는 정해져있지 않다.
   - 따라서 데이터 스트림의 크기가 크거나 무한이라면 문제가 생길 수 있다（예를 들어 모든 소수를 포함하는 스트림을 역순으로 만들면 어떤 일이 일어날까? 첫 번째 요소로 가장 큰 소수，즉 세상에 존재하지 않는 수를 반환해야 한다).
   - 이러한 연산을 내부 상태를 갖는 연산(stateful operation) 이라 한다

// TODO

// TODO foreach vs reduce