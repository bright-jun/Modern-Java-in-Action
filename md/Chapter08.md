# [Chapter 08](https://livebook.manning.com/book/modern-java-in-action/chapter-8/)

# 컬렉션 API 개선

- 컬렉션 팩토리 사용하기
  - 자바 9에 새로 추가
- 리스트 및 집합과 사용할 새로운 관용 패턴 배우기
  - 자바 8에 새로 추가
- 맵과 사용할 새로운 관용 패턴 배우기

## 8.1 컬렉션 팩토리

- UnsupportedOperationException 예외 발생
  - 고정 크기의 리스트를 만들었으므로 요소를 갱신할 순 있지만 새 요소를 추가하거나 요소를 삭제할 순 없다
  - 내부적으로 고정된 크기의 변환할 수 있는 배열로 구현되었기 때문에 이와 같은 일이 일어난다.

- 내부적으로 불필요한 객체 할당
  - 리스트를 인수로 받는 HashSet 생성자
  - 스트림 API

> 컬렉션 리터럴
> 
> 파이썬，그루비 등을 포함한 일부 언어는 컬렉션 리터럴 즉 [42, 1 5] 같은 특별한 문법을 이용해 컬렉션을 만들 수 있는 기능을 지원한다. 자바에서는 너무 큰 언어 변화와 관련된 비용이 든다는 이유로 이와 같은 기능을 지원하지 못했다. 자바 9에서는 대신 컬렉션 API를 개선했다.

### 8.1.1 리스트팩토리

- UnsupportedOperationException 예외 발생
  - 이런 제약이 꼭 나쁜 것은 아니다
  - 컬렉션이 의도치 않게 변하는 것을 막을 수 있기 때문이다.
  - 마지막으로 null 요소는 금지하므로 의도치 않은 버그를 방지하고 조금 더 간결한 내부 구현을 달성했다.

- 오버로딩 vs 가변 인수
  - List 인터페이스를 조금 더 살펴보면 List.of의 다양한 오버로드 버전이 있다는 사실을 알 수
    있다.
  - 내부적으로 가변 인수 버전은 추가 배열을 할당해서 리스트로 감싼다.
  - 배열을 할당하고 초기화하며 나중에 가비지 컬렉션을 하는 비용을 지불해야 한다. 고정된 숫자의 요소(최대 열개까지)를 API로 정의하므로 이런 비용에서 차이가 발생한다.
  - List.of로 열 개 이상의 요소를 가진리스틀 만들 수도 있지만 이 때는 가변 인수를 이용하는 메소드가 사용된다. Set.of와 Map.of 에서도 이와 같은 패턴이 등장함을 확인할 수 있다.

### 8.1.2 집합 팩토리

### 8.1.3 맵 팩토리

## 8.2 리스트와 집합 처리

- remove If : 프레디케이트를 만족하는 요소를 제거한다. List 나 Set 을 구현하거나 그 구현을 상속받은 모든 클래스에서 이용할 수 있다.
- replaceAll : 리스트에서 이용할 수 있는 기능으로 UnaryOperator 함수를 이용해 요소를 바꾼다.
- sort : List 인터페이스에서 제공하는 기능으로 리스트를 정렬한다.

- 자바 8 에 추가
- 이들 메서드는 호출한 컬렉션 자체를 바꾼다. 새로운 결과를 만드는 스트림 동작과 달리 이들 메서드는 기존 컬렉션을 바꾼다.
- 왜 이런 메서드가 추가되었을까? 컬렉션을 바꾸는 동작은 에러를 유발하며 복잡함을 더한다.

### 8.2.1 removelf 메서드

### 8.2.2 replaceAll 메서드

## 8.3 맵 처리

### 8.3.1 forEach 메서드

### 8.3.2 정렬 메서드

### 8.3.3 getOrDefault 메서드

### 8.3.4 계산 패턴

### 8.3.5 삭제 패턴

### 8.3.6 교체 패턴

### 8.3.7 합침

## 8.4 개선된 ConcurrentHashMap

- ConcurrentHashMap 클래스는 동시성 친화적이며 최신 기술을 반영한 HashMap 버전이다.
- ConcurrentHashMap은 내부 자료구조의 특정 부분만 잠궈 동시 추가，갱신 작업을 허용한다
- 따라서 동기화된 Hashtable 버전에 비해 읽기 쓰기 연산 성능이 월등하다(참고로，표준HashMap은 비동기로 동작함).

### 8.4.1 리듀스와검색

- forEach : 각 （키, 값） 쌍에 주어진 액션을 실행
- reduce : 모든 （키, 값） 쌍을 제공된 리듀스 함수를 이용해 결과로 합침
- search : 널이 아닌 값을 반환할 때까지 각 （키, 값） 쌍에 함수를 적용
- 이들 연산은 ConcurrentHashMap의 상태를 잠그지 않고 연산을 수행한다는 점을 주목하자. 
  따라서 이들 연산에 제공한 함수는 계산이 진행되는 동안 바뀔 수 있는 객체，값，순서 등에 의존하지 않아야 한다.
  또한 이들 연산에 병렬성 기준값threshold을 지정해야 한다. 맵의 크기가 주어진 기준값보다 작으면 순차적으로 연산을 실행한다. 기준값을 1로 지정하면 공통 스레드 풀을 이용해 병렬성을 극
  대화한다. Long.MAX_VALUE를 기준값으로 설정하면 한 개의 스레드로 연산을 실행한다. 여러분의 소프트웨어 아키텍처가 고급 수준의 자원 활용 최적화를 사용하고 있지 않다면 기준값 규칙을 따르는 것이 좋다.

### 8.4.2 계수

- ConcurrentHashMap 클래스는 맵의 매핑 개수를 반환하는 mappingCount 메서드를 제공한다.
- 기존의 size 메서드 대신 새 코드에서는 int를 반환하는 mappingCount 메서드를 사용하는 것이좋다.
- 그래야 매핑의 개수가 int의 범위를 넘어서는 이후의 상황을 대처할 수 있기 때문이다.

### 8.4.3 집합뷰

- ConcurrentHashMap 클래스는 ConcurrentHashMap을 집합 뷰로 반환하는 keySet이라는 새메서드를 제공한다.
- 맵을 바꾸면 집합도 바뀌고 반대로 집합을 바꾸면 맵도 영향을 받는다.
- newKeySet이라는 새 메서드를 이용해 ConcurrentHashMap으로 유지되는 집합을 만들 수도 있다