# [Chapter 15](https://livebook.manning.com/book/modern-java-in-action/chapter-15/)

# CompletableFuture와 리액티브 프로그래밍 컨셉의 기초

# 이 장의 내용

- Thread, Future, 자바가 풍부한 동시성 API를 제공하도록 강요하는 진화의 힘
- 비동기 API
- 동시 컴퓨팅의 박스와 채널 뷰
- CompletableFuture 콤비네이터로 박스를 동적으로 연결
- 리액티브 프로그래밍용 자바 9 플로 API의 기초를 이루는 발행 구독 프로토콜
- 리액티브 프로그래밍과 리액티브 시스템

## 최근 소프트웨어 개발 방법 추세

1. 애플리케이션을 실행하는 하드웨어
    1. 멀티코어 프로세서가 발전
    2. 애플리케이션의 속도는 멀티코어 프로세서를 얼마나 잘 활용할 수 있도록 소프트웨어를 개발하는가에 따라 달라질 수 있음
    3. 포크/조인 프레임워크(자바 7)
    4. 병렬 스트림(자바 8)
2. 애플리케이션을 어떻게 구성하는가
    1. 인터넷 서비스에서 사용하는 애플리케이션이 증가
    2. 마이크로서비스 아키텍처
        1. 서비스가 작아진 대신 네트워크 통신이 증가
    3. 다양한 소스의 콘텐츠를 가져와서 사용자가 삶을 풍요롭게 만들도록 합치는 매시업(mashup) 형태
        1. 원격 서비스와 상호작용하는 매시업 애플리케이션의 형식
        2. ![Figure 15.1. A typical mashup application](https://drek4537l1klr.cloudfront.net/urma2/Figures/15fig01_alt.jpg)
        3. 이런 애플리케이션을 구현하려면 인터넷으로 여러 웹 서비스에 접근해야 한다
            1. 서비스의 응답을 기다리는 동안 연산이 블록, 귀중한 CPU 클록 사이클 자원을 낭비할 수 있음
            2. 페이스북의 데이터를 기다리는 동안 트위터 데이터를 처리하지 말란 법은 없다.

## 멀티태스크 프로그래밍

- 병렬성
    - 병렬 실행을 하드웨어 수준에서 지원

    1. 포크/조인 프레임워크
    2. 병렬 스트림
- 동시성
    - 단일 코어 머신에서 발생할 수 있는 프로그래밍 속성으로 실행이 서로 겹칠 수 있음
    - 조금씩 연관된 작업을 같은 CPU에서 동작하는 것
    - 애플리케이션을 생산성을 극대화할 수 있도록 코어를 바쁘게 유지하는 것이 목표
    - 원격 서비스나 데이터베이스 결과를 기다리는 스레드를 볼록함으로 연산 자원을 낭비하는 일은 피해야 한다.

    1. Future 인터페이스로 자바 8의 CompletableFuture 구현
    2. 자바 9에 추가된 발행 구독 프로토콜에 기반한 리액티브 프로그래밍 개념을 따르는 플로 API

- Figure 15.2. Concurrency versus parallelism
    - ![Figure 15.2. Concurrency versus parallelism](https://drek4537l1klr.cloudfront.net/urma2/Figures/15fig02_alt.jpg)
    - 단일 코어 머신에서 발생할 수있는 프로그래밍 속성으로 실행이 서로 겹칠 수 있는

## 15.1 동시성을 구현하는 자바 지원의 진화

### 15.1.1 스레드와 높은 수준의 추상화

### 15.1.2 Executor와 스레드 풀

#### 스레드의 문제

#### 스레드 풀 그리고 스레드 풀이 더 좋은 이유

#### 스레드 풀 그리고 스레드 풀이 나쁜 이유

### 15.1.3 스레드의 다른 추상화: 중첩되지 않은 메서드 호출

### 15.1.4 스레드에 무엇을 바라는가?

## 15.2 동기 API와 비동기 API

### 15.2.1 Future 형식 API

### 15.2.2 리액티브 형식 API

### 15.2.3 잠자기(그리고 기타 블로킹 동작)는 해로운 것으로 간주

### 15.2.4 현실성 확인

### 15.2.5 비동기 API에서 예외는 어떻게 처리하는가?

## 15.3 박스와 채널 모델

## 15.4 CompletableFuture와 콤비네이터를 이용한 동시성

## 퀴즈 15-1

> 다음으로 진행하기 전에 다음과 같은 상황에서 스레드를 완벽하게 활용할 수 있는 태스크를 어떻게 구현할 수 있는지 생각한다. f(x), g(x)를 실행하는 두 개의 활성 스레드가 있는데 한 스레드는 다른 스레드가 return 문을 실행해 종료될 때까지 기다렸다가 시작한다.
>
> 정답은 f(x)를 실행하는 한 태스크,g(x)를 실행하는 두 번째 태스크,합계를 계산하는 세 번째 태스크(이전의 두 태스크를 재활용 할 수 있다) 세 개를 이용하는 것이다. 하지만 처음 두 태스크가 실행되기 전까지 세 번째 태스크는 실행할 수 없다. 자바로 이 문제를 어떻게 해결할 수 있을까?
> 
> Future를 조합해 이 문제를 해결할 수 있다.

## 15.5 발행-구독 그리고 리액티브 프로그래밍

### 15.5.1 두 플로를 합치는 예제

### 15.5.2 역압력

### 15.5.3 실제 역압력의 간단한 형태

## 15.6 리액티브 시스템 vs 리액티브 프로그래밍

## 15.7 마치며

- 자바의 동시성 지원은 계속 진화해 왔으며 앞으로도 그럴 것이다. 스레드 풀은 보통 유용하지만 블록 되는 태스크가 많아지면 문제가 발생한다.
- 메서드를 비동기(결과를 처리하기 전에 반환)로 만들면 병렬형을 추가할 수 있으며 부수적으로 루프를 최적화한다.
- 박스와 채널 모델을 이용해 비동기 시스템을 시각화할 수 있다.
- 자바 8 CompletableFuture 클래스와 자바 9 플로 API 모두 박스와 채널 다이어그램으로 표현할 수 있다.
- CompletableFuture 클래스는 한 번의 비동기 연산을 표현한다. 콤비네이터로 비동기 연산을 조합함으로 Future를 이용할 때 발생했던 기존의 블로킹 문제를 해결할 수 있다.
- 플로 API는 발행-구독 프로토콜, 역 압력을 이용하면 자바의 리액티브 프로그래밍의 기초를 제공한다.
- 리액티브 프로그래밍을 이용해 리액티브 시스템을 구현할 수 있다.