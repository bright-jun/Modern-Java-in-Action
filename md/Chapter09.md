# [Chapter 09](https://livebook.manning.com/book/modern-java-in-action/chapter-9/)

## 리팩터링，테스팅，디버깅

### 9.1 가독성과 유연성을 개선하는 리팩터링

#### 9.1.1 코드가독성개선

- 코드 가독성이 좋다는 것은 ‘어떤 코드를 다른 사람도 쉽게 이해할 수 있음’을 의미한다

#### 9.1.2 익명 클래스를 람다 표현식으로 리팩터링하기

#### 9.1.3 람다 표현식을 메서드 참조로 리팩터링하기

#### 9.1.4 명령형 데이터 처리를 스트림으로 리팩터링하기

#### 9.1.5 코드 유연성 개선

- 함수형 인터페이스 적용
  - 조건부 연기 실행
    - 람다를 통해 메시지 생성 과정을 연기할 수 있다.
    - 객체 상태가 클라이언트 코드로 노출되지 않는다
  - 실행 어라운드

### 9.2 람다로 객체지향 디자인 패턴 리팩터링하기

- 다양한 패턴을 유형별로 정리한 것이 디자인 패턴(design pattern)이다
  - 방문자 디자인 패턴(visitor design pattern)
    - 구조체와 동작하는 알고리즘을 서로 분리하고 싶을 때
  - 싱글턴 패턴(singleton pattern)
    - 클래스 인스턴스화를 하나의 객체로 제한

- 전략 (strategy)
- 템플릿 메서드(template method)
- 옵저버 (observer)
- 의무 체인(chain of responsibility)
- 팩토리 (factory)

#### 9.2.1 전략

- 전략 패턴은 한 유형의 알고리즘을 보유한 상태에서 런타임에 적절한 알고리즘을 선택하는 기법이다.
![그림 9.1 전략 디자인 패턴](https://drek4537l1klr.cloudfront.net/urma2/Figures/09fig01_alt.jpg)
- 알고리즘을 나타내는 인터페이스(Strategy 인터페이스)
- 다양한 알고리즘을 나타내는 한 개 이상의 인터페이스 구현(ConcreteStrategyA, ConcreteStrategyB)같은 구체적인 구현 클래스
- 전략 객체를 사용하는 한 개 이상의 클라이언트
- Validationstrategy 는 함수형 인터페이스며 Predicate<String>과 같은 함수 디스크립터를 갖고 있음을 파악했을 것이다. 따라서 다양한 전략을 구현하는 새로운 클래스를 구현할 필요없이 람다 표현식을 직접 전달하면 코드가 간결해진다.

#### 9.2.2 템플릿 메서드

- 알고리즘의 개요를 제시한 다음에 알고리즘의 일부를 고칠 수 있는 유연함을 제공해야 할 때
- 이 알고리즘을 사용하고 싶은데 그대로는 안 되고 조금 고쳐야 하는 경우

#### 9.2.3 옵저버

- 어떤 이벤트가 발생했을 때 한 객체 (주제subject라 불리는)가 다른 객체 리스트(옵저버observer라 불리는)에 자동으로 알림을 보내야 하는 상황

![그림 9.2 옵저버 디자인 패턴](https://drek4537l1klr.cloudfront.net/urma2/Figures/09fig02_alt.jpg)

#### 9.2.4 의무 체인

- 작업 처리 객체의 체인(동작 체인 등)을 만들 때
- 한 객체가 어떤 작업을 처리한 다음에 다른 객체로 결과를 전달하고，다른 객체도 해야 할 작업을 처리한 다음에 또 다른 객체로 전달하는 식

- ![그림 9.2 의무 체인 디자인 패턴](https://drek4537l1klr.cloudfront.net/urma2/Figures/09fig03.jpg)

#### 9.2.5 팩토리

- 인스턴스화 로직을 클라이 언트에 노출하지 않고 객체를 만들 때
- ex) 은행에서 일하고 있는데 은행에서 취급하는 대출，채권，주식 등 다양한 상품 생성
  - 다양한 상품을 만드는 Factory 클래스가 필요하다

### 9.3 람다 테스팅
